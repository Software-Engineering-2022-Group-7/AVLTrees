{% extends "base.html" %}
{% block title %}
<title>Tutorial</title>
{% endblock %}

{% block content %}
    <main data-bs-spy="scroll" data-bs-target="#navbar_tutorial" data-bs-smooth-scroll="true" tabindex="0">
        <div class="tutorial_sidebar">
            <nav id="navbar_tutorial" class="h-100 flex-column align-items-stretch pe-4">
                <nav class="nav nav-pills flex-column">
                    <a class="nav-link" href="#content_title">Content</a>
                    <nav class="nav nav-pills flex-column">
                        <a class="nav-link ms-3 my-1" href="#Tree">What is an AVL tree?</a>
                        <a class="nav-link ms-3 my-1" href="#Binary_tree">What is a binary tree?</a>
                        <a class="nav-link ms-3 my-1" href="#Binary_search_tree">What is a binary search tree?</a>
                        <a class="nav-link ms-3 my-1" href="#Self_balancing_binary_search_tree">What is a self-balancing binary search tree?</a>
                        <a class="nav-link ms-3 my-1" href="#AVL_tree_background">Who made AVL trees?</a>
                        <a class="nav-link ms-3 my-1" href="#AVL_tree_differences">How do AVL trees differ from binary search trees?</a>
                    </nav>
                </nav>
            </nav>
        </div>

        <h1 id="content_title">What is an AVL tree?</h1>

        <h3 id="Tree">What is a tree?</h3>
        <ul>
            <li>A tree is a kind of data structure.</li>
            <li>Trees are a collection of nodes.</li>
            <ul class="secondary_list">
                <li>Nodes have a key and a value associated with them.</li>
                <li>They can also have child nodes, or nodes on the level below that they are connected to.</li>
            </ul>
            <li>It's shaped like an upside down tree, or like tree roots, hence the name.</li>
            <li>We call the first node at the top the "root."</li>
            <li>We call a node without any children a "leaf" node.</li>
            <li>What is depth? What is height?</li>
            <ul class="secondary_list">
                <li>Depth and height are important concepts of trees.</li>
                <li>Depth is the number of steps away from the root node a node is.</li>
                <li>Height is the maximum number of steps from a node to its leaf nodes.</li>
            </ul>
            <li>An example of a tree:</li>
<pre>     C
 / /   \ \
D A     F G
|        / \
B       E   H</pre>
            <li>In the above example:</li>
            <ul class="secondary_list">
                <li>Node G has a depth of 1 and a height of 1.</li>
                <li>Node B has a depth of 2 and a height of 0.</li>
                <li>Node C has a depth of 0 and a height of 2.</li>
            </ul>
            <li>What information can we get from a tree? What operations can we perform?</li>
            <ul class="secondary_list">
                <li>Get the number of nodes in the tree (its size).</li>
                <li>Get the value associated with a node's key.</li>
                <li>Get the height of the tree.</li>
                <li>Get the maximum and minimum key in the tree.</li>
                <li>Check if the tree has a node with a specific key.</li>
                <li>Insert a new node into the tree.</li>
                <li>Update an existing node's value.</li>
                <li>Remove a node with a specific key from the tree.</li>
                <li>...And more!</li>
            </ul>
        </ul>

        <h3 id="Binary_tree">What is a binary tree?</h3>
        <ul>
            <li>A binary tree is a tree in which each node is allowed at most two children.</li>
            <li>An example of a binary tree:</li>
<pre>     C
   /   \
  D     A
 / \     \
F   G     E
     \     \
      B     H</pre>
            <li>What are traversals?</li>
            <ul class="secondary_list">
                <li>Traversals are a list of the nodes in a tree. There are 4 different
                kinds of traversals that produce a different order of nodes.</li>
                <ol class="secondary_list">
                    <li>A pre-order traversal visits the current node first, then recursively
                    visits the node's left subtree, then the node's right subtree.</li>
                    <li>A pre-order traversal recursively visits the current node's left
                    subtree first, then the node's right subtree, then the node itself.</li>
                    <li>An in-order traversal recursively visits the current node's left subtree
                    first, then the node itself, then the node's right subtree.</li>
                    <li>A level-order traversal uses a breadth-first search approach.</li>
                </ol>
            </ul>
        </ul>

        <h3 id="Binary_search_tree">What is a binary search tree?</h3>
        <ul>
            <li>A binary search tree is a binary tree that has three properties. For any node:</li>
            <ol class="secondary_list">
                <li>The left subtree of the node only has nodes with keys less than the node's key.</li>
                <li>The right subtree of the node only has nodes with keys more than the node's key.</li>
                <li>The left and right subtree of the node must also be binary search trees.</li>
            </ol>
            <li>An example of a binary search tree:</li>
<pre>     D
   /   \
  B     F
 / \     \
A   C     G
     \     \
      E     H</pre>
        </ul>

        <h3 id="Self_balancing_binary_search_tree">What is a self-balancing binary search tree?</h3>
        <ul>
            <li>A self-balancing binary search tree is a binary search tree that performs some operation on itself
            when it becomes unbalanced.</li>
            <li>What is balance?</li>
            <ul class="secondary_list">
                <li>Balance is the difference in heights between the left and right subtrees of a node.</li>
                <li>There are four cases of unbalance in a tree:</li>
                <ol class="secondary_list">
                    <li>Left left:</li>
<pre>    C
   /
  B
 /
A</pre>
                    <li>Left right:</li>
<pre>  C
 /
A
 \
  B</pre>
                    <li>Right right:</li>
<pre>A
 \
  B
   \
    C</pre>

                    <li>Right left:</li>
<pre>A
 \
  C
 /
B</pre>
                </ol>
                <li>Trees can become unbalanced when a new node is inserted or when
                an existing node is removed.</li>
            </ul>
        </ul>

        <h3 id="AVL_tree_background">Who made AVL trees?</h3>
        <ul>
            <li>AVL trees were invented by Georgy Adelson-Velsky and Evgenii Landis.</li>
            <li>AVL trees were the first kind of self-balancing binary search tree.</li>
        </ul>

        <h3 id="AVL_tree_differences">How do AVL trees differ from binary search trees?</h3>
        <ul>
            <li>An AVL tree is a kind of self-balancing binary search tree that performs rotations on nodes when
            it becomes unbalanced. The kind of rotation depends on how the tree is unbalanced.</li>
            <ol class="secondary_list">
                <li>Left left:</li>
<pre>    C                          B
   /     rightRotate(C)       / \
  B     --------------->     A   C
 /
A</pre>
                <li>Left right:</li>
<pre>  C                          C                          B
 /     leftRotate(A)        /     rightRotate(C)       / \
A     --------------->     B     --------------->     A   C
 \                        /
  B                      A</pre>
                <li>Right right:</li>
<pre>A                              B
 \       leftRotate(A)        / \
  B     --------------->     A   C
   \
    C</pre>
                <li>Right left:</li>
<pre>
A                          A                              B
 \       rightRotate(C)     \       leftRotate(A)        / \
  C     --------------->     B     --------------->     A   C
 /                            \
B                              C
</pre>
            </ol>
        </ul>
    </main>
{% endblock %}
